<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>木夕木火のBlog</title>
  
  <subtitle>革命尚未成功，同志仍需努力</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wmjtxt.github.io/"/>
  <updated>2019-06-27T10:05:19.442Z</updated>
  <id>https://wmjtxt.github.io/</id>
  
  <author>
    <name>木夕木火</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>克隆Deepin系统</title>
    <link href="https://wmjtxt.github.io/2019/06/27/cloneDeepin/"/>
    <id>https://wmjtxt.github.io/2019/06/27/cloneDeepin/</id>
    <published>2019-06-27T08:08:26.000Z</published>
    <updated>2019-06-27T10:05:19.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h1><p>换了新电脑，就想着能否把原来的系统迁移到新电脑上，毕竟新配置一个系统还是挺麻烦的。在论坛搜了一下，看到有说可以clone分区。然后就试了一下，开始遇到一些问题，不过后来还是成功了。</p><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>新电脑是AMD锐龙处理器，自带Windows10，原Deepin系统是在大小110G左右的固态硬盘上，另有一个238G左右的移动固态硬盘。</p><h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>将Deepin系统从110G的硬盘克隆到238G的硬盘上。 </p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>克隆完成后，将238G的硬盘连到新电脑，无法从该硬盘启动，Boot Device只显示电脑自带的硬盘而不显示外接硬盘。这样就没办法启动克隆的系统。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>鉴于之前我曾在238G的硬盘上安装了Deepin 15.10，并在新电脑成功启动过，所以就想在电脑自带的硬盘安装一个Deepin系统，或许能解决这个问题。果不其然。</p><p>ps : 一直以来，我都是用Windows10+Deepin双系统，efi引导启动(引导这块不太懂，我是先装好Windows10，再安装Deepin，然后开机就看到引导界面了，所以应该是Deepin自带的引导程序)。</p><h1 id="为什么不用Deepin-15-10-以下简称15-10-了"><a href="#为什么不用Deepin-15-10-以下简称15-10-了" class="headerlink" title="为什么不用Deepin 15.10(以下简称15.10)了"></a>为什么不用Deepin 15.10(以下简称15.10)了</h1><p>其实先前是打算趁这次换电脑改用Deepin 15.10而放弃原来的Deepin 15.9(下称15.9)的(从15.5开始用，一路升级到15.9)，因为15.10是第一个stable版本，而且原来的unstable版本官方好像是今年7月以后不再更新了。</p><p>所以新电脑一到，我就在238G移动固态上安装了15.10，一开始没发现什么大问题，只是<strong>引导有点问题</strong>：每次从Windows10重启，无法正常进入引导界面。这也许是本地硬盘Windows10+移动硬盘Deepin的问题，也可能是AMD处理器的问题。</p><p>另外，在安装一个vim插件的时候（vim-instant-markdown），需要安装nodejs，而在15.10安装nodejs默认版本是4.8，在15.9安装是8.11，不知道是不是由于这个原因，总之结果就是<strong>vim-instant-markdown在15.10用不了</strong>，尝试了各种方法结果还是不行。</p><p>综上，我就决定暂时放弃15.10了，虽然[解决办法]里在新电脑自带硬盘安装的系统是15.10，但那只是工具而已，以后的主力系统还是15.9。或许以后还有机会再用15.10或者别的linux系统。</p><h1 id="实施步骤"><a href="#实施步骤" class="headerlink" title="实施步骤"></a>实施步骤</h1><p>大致说一下实施步骤，因为我先后尝试了多次，所以这里就不赘述，只说我认为是必要的步骤，如果遇到问题，欢迎留言交流。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li><p>原始系统，简称<strong>Deepin-老大</strong>；目标系统，也就是克隆系统，简称<strong>Deepin-小二</strong>。</p></li><li><p>一个第三方Deepin系统（我是在另一个移动机械硬盘上安装过一个Deepin 15.7，正好派上用场），简称<strong>Deepin-小三</strong>。<br>用live系统应该也可以，不过我没有试。如果在Deepin-老大上执行clone操作的话，会提示有个错误，好像是让你重启进入live系统再clone（我第一次是这样弄的，记不太清了，后来都是在第三方系统clone的）。</p></li><li><p>安装Clone软件（中文名是备份还原工具），在深度商店里就有。</p></li><li><p>在新电脑自带硬盘压缩出一个60G大小的空间并新建分区（这个过程是在自带Windows10系统进行），安装Deepin系统，简称<strong>Deepin-小四</strong>。</p></li></ul><h3 id="克隆系统"><a href="#克隆系统" class="headerlink" title="克隆系统"></a>克隆系统</h3><p>打开Clone软件，第一步选择操作介质: 分区，选择介质对应的操作: 克隆分区，然后点击下一步，选择原始分区和目标分区，点击开始克隆，等待完成。</p><h3 id="在新电脑启动"><a href="#在新电脑启动" class="headerlink" title="在新电脑启动"></a>在新电脑启动</h3><p>克隆完成后，建议就转移到新电脑，先启动<strong>Deepin-小四</strong>，执行命令<code>sudo update-grub</code>，然后重启就可以进入引导界面，并发现里面有<strong>Deepin-小二</strong>，就说明克隆成功了。</p><p>之所以不建议在旧电脑启动<strong>Deepin-小二</strong>，是因为在旧电脑，<strong>Deepin-老大</strong>和<strong>Deepin-小二</strong>同时存在，引导程序可能对他们在识别上有点问题。<br>我在<strong>Deepin-小三</strong>执行<code>sudo update-grub</code>后，引导程序的确发现了这两个在不同位置的一模一样的系统，但启动的时候不论点击哪一个，似乎启动的都是原来的<strong>Deepin-老大</strong>。</p><h3 id="解决Deepin-小二分区大小问题"><a href="#解决Deepin-小二分区大小问题" class="headerlink" title="解决Deepin-小二分区大小问题"></a>解决Deepin-小二分区大小问题</h3><p>启动<strong>Deepin-小二</strong>后，你也许会发现这个问题：<code>df -h</code>命令的结果显示，系统盘大小是110G（原系统Deepin-老大所在分区的大小），而<code>sudo fdisk -l</code>命令显示系统盘分区大小是238G（就是克隆操作目标硬盘的大小）。</p><p>那些多余的空间去哪了？能不能找回来呢？答案是可以！</p><p>只需要执行如下命令：</p><p><code>resize2fs /dev/sda1</code></p><p>其中<code>/dev/sda1</code>是系统<strong>Deepin-小二</strong>所在的分区名字。</p><h3 id="领衔主演"><a href="#领衔主演" class="headerlink" title="领衔主演"></a>领衔主演</h3><table><thead><tr><th style="text-align:center">姓名</th><th style="text-align:center">版本</th><th style="text-align:center">系统盘大小</th></tr></thead><tbody><tr><td style="text-align:center">Deepin-老大</td><td style="text-align:center">15.9.3</td><td style="text-align:center">110G</td></tr><tr><td style="text-align:center">Deepin-小二</td><td style="text-align:center">15.9.3</td><td style="text-align:center">238G</td></tr><tr><td style="text-align:center">Deepin-小三</td><td style="text-align:center">15.7.0</td><td style="text-align:center">80G</td></tr><tr><td style="text-align:center">Deepin-小四</td><td style="text-align:center">15.10.1</td><td style="text-align:center">60G</td></tr></tbody></table><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>还有一些别的办法克隆系统，比如先备份，再还原，不再一一尝试啦，毕竟系统只是工具，弄好了就该办正事了，这才是最重要的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h1&gt;&lt;p&gt;换了新电脑，就想着能否把原来的系统迁移到新电脑上，毕竟新配置一个系统还是挺麻烦的。在论坛搜了一下，看到有说可以clone分区。然后就试了一下
      
    
    </summary>
    
    
      <category term="Deepin" scheme="https://wmjtxt.github.io/tags/Deepin/"/>
    
      <category term="linux" scheme="https://wmjtxt.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>命名空间Namespace数据成员重复定义问题</title>
    <link href="https://wmjtxt.github.io/2019/04/23/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4namespace%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E9%87%8D%E5%A4%8D%E5%AE%9A%E4%B9%89%E9%97%AE%E9%A2%98/"/>
    <id>https://wmjtxt.github.io/2019/04/23/命名空间namespace数据成员重复定义问题/</id>
    <published>2019-04-23T13:40:14.000Z</published>
    <updated>2019-06-27T07:34:05.888Z</updated>
    
    <content type="html"><![CDATA[<p>C++ Primer终于快看完了。<br>真是越往后看的越慢，跳过了几章，今天直接看第18章命名空间部分，遇到了一个小问题。如下所示。<br>文件：</p><a id="more"></a><ul><li><p>np.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NP_H__ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NP_H__ </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> np&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NpTest</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;)</span></span>;</span><br><span class="line">    <span class="comment">//int np_val;//这样不行，重复定义，用嵌套的匿名空间可以，如下所示(不太清楚为啥。。。)</span></span><br><span class="line">    <span class="keyword">namespace</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> np_val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p>np.cpp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"np.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> np;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> np&#123;</span><br><span class="line">    <span class="keyword">void</span> NpTest::print()&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"val = "</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">        ++a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>main.cpp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"np.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> np;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> np1&#123;</span><br><span class="line">    <span class="keyword">int</span> np_val = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> np1&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ++np_val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    NpTest a;</span><br><span class="line">    a.print();</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    add(x);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    np::np_val = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; np::np_val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; np1::np_val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    np1::test();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; np1::np_val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Problem: 其实就是注释的那一行，np_val存在重复定义问题。<br>就是每当np.h被include一次，np_val就被定义一次。<br>但是改成把np_val放到嵌套的匿名空间里就没有问题了。<br>现在还不太理解原因，待后面再看看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++ Primer终于快看完了。&lt;br&gt;真是越往后看的越慢，跳过了几章，今天直接看第18章命名空间部分，遇到了一个小问题。如下所示。&lt;br&gt;文件：&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://wmjtxt.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>木夕的诗</title>
    <link href="https://wmjtxt.github.io/2019/04/10/mjpoet/"/>
    <id>https://wmjtxt.github.io/2019/04/10/mjpoet/</id>
    <published>2019-04-10T01:01:34.000Z</published>
    <updated>2019-06-27T07:34:05.896Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/sunset.jpg" alt="sunset"></p><p>一些旧诗，陆续整理中…</p><a id="more"></a><h6 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h6><p><a href="#夜思">夜思</a><br><a href></a><br><a href></a><br><a href></a></p><h6 id="夜思"><a href="#夜思" class="headerlink" title="夜思"></a>夜思</h6><p>2009.10.01 于海口<br>黛入秋空忽夜半，窗台露水月如弓。<br>风冲雾里花滴落，雨撞墙根草速生。<br>语逸心烦德不事，情闲意乱道难清。<br>方思铁血南疆撒，岂敢从心荡鼓钟。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/sunset.jpg&quot; alt=&quot;sunset&quot;&gt;&lt;/p&gt;
&lt;p&gt;一些旧诗，陆续整理中…&lt;/p&gt;
    
    </summary>
    
    
      <category term="诗歌" scheme="https://wmjtxt.github.io/tags/%E8%AF%97%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title>饮酒</title>
    <link href="https://wmjtxt.github.io/2019/03/31/drink/"/>
    <id>https://wmjtxt.github.io/2019/03/31/drink/</id>
    <published>2019-03-31T13:49:40.000Z</published>
    <updated>2019-06-27T07:34:05.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="饮酒"><a href="#饮酒" class="headerlink" title="饮酒"></a>饮酒</h1><p>陶渊明</p><p>结庐在人境，而无车马喧。<br>问君何能尔？心远地自偏。<br>采菊东篱下，悠然见南山。<br>山气日夕佳，飞鸟相与还。<br>此中有真意，欲辨已忘言。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;饮酒&quot;&gt;&lt;a href=&quot;#饮酒&quot; class=&quot;headerlink&quot; title=&quot;饮酒&quot;&gt;&lt;/a&gt;饮酒&lt;/h1&gt;&lt;p&gt;陶渊明&lt;/p&gt;
&lt;p&gt;结庐在人境，而无车马喧。&lt;br&gt;问君何能尔？心远地自偏。&lt;br&gt;采菊东篱下，悠然见南山。&lt;br&gt;山气日夕佳，飞鸟相与还
      
    
    </summary>
    
    
      <category term="诗歌" scheme="https://wmjtxt.github.io/tags/%E8%AF%97%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title>旧照片</title>
    <link href="https://wmjtxt.github.io/2019/03/30/oldPhotos/"/>
    <id>https://wmjtxt.github.io/2019/03/30/oldPhotos/</id>
    <published>2019-03-30T14:03:30.000Z</published>
    <updated>2019-06-27T07:34:05.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些照片"><a href="#一些照片" class="headerlink" title="一些照片"></a>一些照片</h1><a id="more"></a><p><img src="/myPhoto/20140930_115321.jpg" alt><br><img src="/myPhoto/DSC00483.JPG" alt><br><img src="/myPhoto/DSC00484.JPG" alt><br><img src="/myPhoto/DSC00485.JPG" alt><br><img src="/myPhoto/DSC00486.JPG" alt><br><img src="/myPhoto/DSC00487.JPG" alt><br><img src="/myPhoto/DSC_0134.JPG" alt><br><img src="/myPhoto/DSC_0240.JPG" alt><br><img src="/myPhoto/DSC_0248.JPG" alt><br><img src="/myPhoto/DSC_0254.JPG" alt><br><img src="/myPhoto/DSC_0255.JPG" alt><br><img src="/myPhoto/DSC_0274.JPG" alt><br><img src="/myPhoto/IMG20150626016.jpg" alt><br><img src="/myPhoto/1岁.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一些照片&quot;&gt;&lt;a href=&quot;#一些照片&quot; class=&quot;headerlink&quot; title=&quot;一些照片&quot;&gt;&lt;/a&gt;一些照片&lt;/h1&gt;
    
    </summary>
    
    
      <category term="照片" scheme="https://wmjtxt.github.io/tags/%E7%85%A7%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>Reading</title>
    <link href="https://wmjtxt.github.io/2019/03/30/reading/"/>
    <id>https://wmjtxt.github.io/2019/03/30/reading/</id>
    <published>2019-03-30T13:16:37.000Z</published>
    <updated>2019-06-27T07:34:05.892Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/myPhoto/DSC_0274.JPG" alt="pic"></p><h5 id="读书笔记-C-Primer"><a href="#读书笔记-C-Primer" class="headerlink" title="读书笔记 C++ Primer"></a>读书笔记 C++ Primer</h5><p>这本800多页的大块头，我已经翻了很久了。才看一半左右。刚开始的看的很快，一天近百页，两三天后就啃不动了。<br>越到后面新知识越多，也越来越难理解，因为前面几章是基础，后面是各种复杂的东西，容器、动态内存、拷贝控制什么的。<br>不过还是要尽快看。前几天因为实验室还有论文的事情耽误了些时间，后面几天应该没啥事了。专心看书，啃书。看完这本，还有三本……<br>其实不止……比如STL剖析、Linux内核与实现、csapp、EffectiveC++、Redis、MySQL等等。真的是太多书需要看了。</p><a id="more"></a><h5 id="摄影"><a href="#摄影" class="headerlink" title="摄影"></a>摄影</h5><p>相机一直在睡觉。</p><p>我的所谓爱好摄影何止是一句空话，简直是真空的。不过今天翻了翻相册，以前拍的照片，质量还不错的（比如文首所示），<br>它们也一直在睡觉。自从拍完回来，从手机或相机的存储卡里拷贝到电脑里，就再也没“惠顾”过他们！</p><p>其实有时间可以多出门拍拍照片，把这个爱好给坐实了！比如上次文学院的同学邀请，就可以去啊，虽然认识的方式略尴尬，但也无伤大雅。<br>也不是以找对象为纯粹目的的啊，做个朋友总是可以的。嗯，有时间问一下。</p><h5 id="找实习"><a href="#找实习" class="headerlink" title="找实习"></a>找实习</h5><p>参加了不少笔试，面试不多，面了的也一个都没过。现状是基础不牢、项目不精，要啥啥不行。还是补基础先。</p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>兰大双选会其实就是个大型招聘会，是挺不错的，不过跟我们专业关系不太大。</p><p>作息方面，基本上达到要求了，还需要长期坚持。尽量做到不玩手机，虽然现在已经玩的很少了，但还没有完全杜绝。</p><p>个人形象方面，既然丑的事实已经无法改变，那就只能接受，并在其他方面做出补充。比如健身，发型，衣着等等。<br>说到底，我还是一个在意外表的人。以前嘛，不修边幅，对长相还自信，所以也没啥。现在呢，要啥没啥了，天天跟裸奔一样，很不自在。<br>这一点亟待改善。</p><p>就说这么多吧，兰州最近的昼夜温差挺大的，不穿秋裤晚上还挺冷的！</p><p>2019,03,30 二月廿四 星期六</p><p>于兰州</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/myPhoto/DSC_0274.JPG&quot; alt=&quot;pic&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;读书笔记-C-Primer&quot;&gt;&lt;a href=&quot;#读书笔记-C-Primer&quot; class=&quot;headerlink&quot; title=&quot;读书笔记 C++ Primer&quot;&gt;&lt;/a&gt;读书笔记 C++ Primer&lt;/h5&gt;&lt;p&gt;这本800多页的大块头，我已经翻了很久了。才看一半左右。刚开始的看的很快，一天近百页，两三天后就啃不动了。&lt;br&gt;越到后面新知识越多，也越来越难理解，因为前面几章是基础，后面是各种复杂的东西，容器、动态内存、拷贝控制什么的。&lt;br&gt;不过还是要尽快看。前几天因为实验室还有论文的事情耽误了些时间，后面几天应该没啥事了。专心看书，啃书。看完这本，还有三本……&lt;br&gt;其实不止……比如STL剖析、Linux内核与实现、csapp、EffectiveC++、Redis、MySQL等等。真的是太多书需要看了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://wmjtxt.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>博客迁移到Hexo</title>
    <link href="https://wmjtxt.github.io/2019/03/29/blog-transfer-to-Hexo/"/>
    <id>https://wmjtxt.github.io/2019/03/29/blog-transfer-to-Hexo/</id>
    <published>2019-03-29T06:49:54.000Z</published>
    <updated>2019-06-27T07:34:05.892Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/path.jpg" alt="img"></p><p>把博客迁移到<a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">hexo</a>了，主题是<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia</a>,<br>比原来的好看，也好用。不过这个主题的作者好像不更新了，以后可以换别的主题试试。<br>其实之前就想试试Hexo，当时安装Node.js出了点问题，就放弃了。这次也碰到问题了，不过参考网上的方法很快解决了，<br><a href="https://www.jianshu.com/p/31744aa44824" target="_blank" rel="noopener">这里是方法链接</a>。</p><a id="more"></a><p>然后，简单了解了一下Hexo的命令，就可以开始使用Hexo啦。原来需要<code>git add/commit/push</code>几条命令才能发布，<br>现在只需要一条命令(<code>hexo g -d</code>)就可以了。</p><p>下面简单说一下步骤。</p><ul><li>安装Node.js, Git</li><li>安装Hexo : <code>npm install hexo-cli -g</code></li><li>Setup your blog : <code>hexo init blog</code> </li><li>进入blog<code>cd blog</code>并下载主题 : <code>git clone https://github.com/litten/hexo-theme-yilia.git theme/yilia</code></li><li>选择主题<code>theme: yilia</code></li><li><p>配置<code>/blog/_config.yml</code></p><ul><li><code>new_post_name: year-:month-:day:title.md</code></li><li><code>deploy:</code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type: git</span><br><span class="line">repository: git@github.com:yourname/yourname.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure></li></ul></li><li><p>常用Hexo命令</p><ul><li>新建博客：<code>hexo new title</code></li><li>发布：<code>hexo g -d</code></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/path.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;把博客迁移到&lt;a href=&quot;https://github.com/hexojs/hexo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo&lt;/a&gt;了，主题是&lt;a href=&quot;https://github.com/litten/hexo-theme-yilia&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;yilia&lt;/a&gt;,&lt;br&gt;比原来的好看，也好用。不过这个主题的作者好像不更新了，以后可以换别的主题试试。&lt;br&gt;其实之前就想试试Hexo，当时安装Node.js出了点问题，就放弃了。这次也碰到问题了，不过参考网上的方法很快解决了，&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/31744aa44824&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里是方法链接&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://wmjtxt.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>GDB and Make</title>
    <link href="https://wmjtxt.github.io/2019/03/25/gdb_make/"/>
    <id>https://wmjtxt.github.io/2019/03/25/gdb_make/</id>
    <published>2019-03-25T05:00:00.000Z</published>
    <updated>2019-06-27T07:34:05.896Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href>MySQL</a></li><li><a href>Oracle</a></li><li><a href>poi</a></li><li><a href>epoll</a><a id="more"></a></li><li><a href>redis</a></li><li><a href>log4cpp</a></li><li><a href>socket</a></li><li><a href>C/S模式</a></li><li><a href>C++, Java, Python</a></li><li><a href>STL</a></li><li><a href>Linux环境编程</a></li><li><a href="#gdb">GDB</a></li><li><a href="#make">Make</a></li><li><a href>多线程编程</a></li><li><a href>git,github</a></li></ul><h1 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h1><ul><li><p>1.编译时加上-g</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ *.cpp -g</span><br></pre></td></tr></table></figure></li><li><p>2.执行时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gdb a.out</span><br></pre></td></tr></table></figure></li></ul><p>或者分两步<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gdb</span><br><span class="line">(gdb)file a.out</span><br></pre></td></tr></table></figure></p><ul><li>命令</li></ul><table><thead><tr><th>命令</th><th>含义</th><th>对应windows</th></tr></thead><tbody><tr><td>l</td><td>显示代码</td><td></td></tr><tr><td>r</td><td>开始运行</td><td>F9</td></tr><tr><td>b 4</td><td>在第四行设置断点</td><td>F5</td></tr><tr><td>info b</td><td>查看所有断点</td><td></td></tr><tr><td>delete [断点号]</td><td>查看所有断点</td><td></td></tr><tr><td>n</td><td>下一步,不进入函数</td><td>F10</td></tr><tr><td>s</td><td>表示单步进入函数</td><td>F11</td></tr><tr><td>p i</td><td>打印变量i</td><td></td></tr><tr><td>c</td><td>继续运行,直到函数结束或遇到新的断点</td><td></td></tr><tr><td>q</td><td>退出</td></tr></tbody></table><h1 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h1><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target: dependency_files</span><br><span class="line">&lt; tab &gt; command</span><br></pre></td></tr></table></figure><p>.PHONY是Makefile文件的关键字，表示它后面列表中的目标均为伪目标。伪目标通常用在清理文件、强制重新编译等情况下</p><p>自定义文件名的话,比如makename执行时在后面加上-f makename</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -f makename</span><br></pre></td></tr></table></figure><p><strong>变量函数与规则</strong></p><p>随着项目越来越大，源文件也越来越复杂，这个时候就要用到变量，写出通用性较强的makefile文件</p><h2 id="定义变量的两种方法"><a href="#定义变量的两种方法" class="headerlink" title="定义变量的两种方法"></a>定义变量的两种方法</h2><ul><li>1.变量名=变量值   递归变量展开（几个变量共享一个值） //不常用</li><li>2.变量名:=变量值  简单变量展开（类似于C++的赋值）    //常用</li></ul><p>变量分为; 用户自定义变量，预定义变量（CFLAGS），自动变量，环境变量</p><p>自动变量：指在使用的时候，自动用特定的值替换，常用的有: </p><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>$@</td><td>当前规则的目标文件（重点）</td></tr><tr><td>$&lt;</td><td>当前规则的第一个依赖文件</td></tr><tr><td>$^</td><td>当前规则的所有依赖文件，以空格分隔（重点）</td></tr><tr><td>$?</td><td>规则中日期新于目标文件的所有相关文件列表，逗号分隔</td></tr><tr><td>$(@D)</td><td>目标文件的目录名部分</td></tr><tr><td>$(@F)</td><td>目标文件的文件名部分</td></tr></tbody></table><p>预定义变量：内部事先定义好的变量，但是它的值是固定的，并且有些的值是为空的。</p><ul><li>AR: 库文件打包程序默认为ar</li><li>AS: 汇编程序，默认为as</li><li>CC: c编译器默认为cc</li><li>CPP: C预编译器，默认为$(CC) -E</li><li>CXX: C++编译器，默认为g++</li><li>RM: 删除，默认为rm -f</li><li>ARFLAGS: 库选项，无默认</li><li>ASFLAGS: 汇编选项，无默认</li><li>CFLAGS: c编译器选项，无默认</li><li>CPPFLAGS: c预编译器选项，无默认</li><li>CXXFLAGS: c++编译器选项</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p>1.wildcard : 搜索当前目录下的文件名，展开成一列所有符合由其参数描述的文件名，文件间以空格间隔。<br><code>SOURCES=$(wildcard *.cpp)</code>把当前目录下所有.cpp文件存入变量SOURCES里。</p></li><li><p>2.字符串替换函数: $(patsubst要查找的子串，替换后的目标子串，源字符串)。将源字符串(以空格分隔)中的<br>所有要查找的子串替换成目标子串。如OBJS=$(patsubst %.cpp,%.o,$(SOURCES))<br>把SOURCES中的.cpp替换为.o</p></li><li><p>3.$(addprefix 前缀，源字符串)函数把第二个参数列表的每一项前缀上第一个参数值???</p></li></ul><p>下面是一个较为通用的makefile:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DIR      := ./debug</span><br><span class="line">EXE      := <span class="variable">$(DIR)</span>/main.exe</span><br><span class="line">CC       := g++</span><br><span class="line">LIBS     :=</span><br><span class="line">SRCS     := <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span> <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span> <span class="variable">$(<span class="built_in">wildcard</span> *.cc)</span></span><br><span class="line">OCPP     := <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, <span class="variable">$(DIR)</span>/%.o, $(<span class="built_in">wildcard</span> *.cpp)</span>)</span><br><span class="line">OC       := <span class="variable">$(<span class="built_in">patsubst</span> %.c, <span class="variable">$(DIR)</span>/%.co, $(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line">OCC      := <span class="variable">$(<span class="built_in">patsubst</span> %.cc, <span class="variable">$(DIR)</span>/%.cco, $(<span class="built_in">wildcard</span> *.cc)</span>)</span><br><span class="line">OCC      := <span class="variable">$(OC)</span> <span class="variable">$(OCC)</span> <span class="variable">$(OCPP)</span></span><br><span class="line">RM       := rm -rf</span><br><span class="line">CXXFLAGS := -Wall -g</span><br><span class="line">start : mkdebug <span class="variable">$(EXE)</span></span><br><span class="line">mkdebug :</span><br><span class="line">    @if[! -d <span class="variable">$(DIR)</span>]; then mkdir <span class="variable">$(DIR)</span>; fi;</span><br><span class="line"><span class="variable">$(EXE)</span> : <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$(OBJS)</span> <span class="variable">$(<span class="built_in">addprefix</span> -l, <span class="variable">$(LIBS)</span>)</span></span><br><span class="line"><span class="variable">$(DIR)</span>/%.o : %.cpp</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(DIR)</span>/%.co : %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(DIR)</span>/%.cco : %.cc</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">.PHONY : clean rebuild</span><br><span class="line">clean :</span><br><span class="line">    @D<span class="variable">$(RM)</span> <span class="variable">$(DIR)</span>/*.exe <span class="variable">$(DIR)</span>/*.o <span class="variable">$(DIR)</span>/*.co <span class="variable">$(DIR)</span>/*.cco</span><br><span class="line">rebuild : clean start</span><br></pre></td></tr></table></figure><h2 id="make的命令行选项"><a href="#make的命令行选项" class="headerlink" title="make的命令行选项"></a>make的命令行选项</h2><table><thead><tr><th>命令格式</th><th>含义</th></tr></thead><tbody><tr><td>-C dir</td><td>读入指定目录下的makefile</td></tr><tr><td>-f file</td><td>读入当前目录下的file文件作为makefile</td></tr><tr><td>-i</td><td>忽略所有的命令行执行错误</td></tr><tr><td>-I dir</td><td>指定被包含的makefile所在目录</td></tr><tr><td>-n</td><td>只打印要执行的命令，但不执行这些命令</td></tr><tr><td>-p</td><td>显示make变量数据库和隐含规则</td></tr><tr><td>-s</td><td>在执行命令时不显示命令</td></tr><tr><td>-w</td><td>如果make在执行过程中改变目录, 则打印当前目录名</td></tr></tbody></table><h2 id="采用for循环编译多个目标文件的Makefile写法"><a href="#采用for循环编译多个目标文件的Makefile写法" class="headerlink" title="采用for循环编译多个目标文件的Makefile写法"></a>采用for循环编译多个目标文件的Makefile写法</h2><p>…</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href&gt;MySQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&gt;Oracle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&gt;poi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&gt;epoll&lt;/a&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://wmjtxt.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="C++" scheme="https://wmjtxt.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Find+wc统计代码行数(文件名含空格)</title>
    <link href="https://wmjtxt.github.io/2019/03/25/find_wc/"/>
    <id>https://wmjtxt.github.io/2019/03/25/find_wc/</id>
    <published>2019-03-25T04:00:00.000Z</published>
    <updated>2019-06-27T07:34:05.892Z</updated>
    
    <content type="html"><![CDATA[<p>一开始这样写<code>find . -name &quot;*.cpp&quot; | xargs wc -l</code>，名字有空格的文件无法处理</p><p>后来就在网上找，下面这个方法可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br><span class="line">find . -name "*.cpp" -print0 | xargs -0 wc -l</span><br></pre></td></tr></table></figure><p>好像是把空格替换成’\0’了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一开始这样写&lt;code&gt;find . -name &amp;quot;*.cpp&amp;quot; | xargs wc -l&lt;/code&gt;，名字有空格的文件无法处理&lt;/p&gt;
&lt;p&gt;后来就在网上找，下面这个方法可以：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;
      
    
    </summary>
    
    
      <category term="shell" scheme="https://wmjtxt.github.io/tags/shell/"/>
    
      <category term="linux" scheme="https://wmjtxt.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令总结(持续更新)</title>
    <link href="https://wmjtxt.github.io/2019/03/18/linux_command/"/>
    <id>https://wmjtxt.github.io/2019/03/18/linux_command/</id>
    <published>2019-03-18T04:00:00.000Z</published>
    <updated>2019-06-27T07:34:05.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><a id="more"></a><table><thead><tr><th>命令</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td><code>df -h</code></td><td>查看磁盘使用情况</td><td>磁盘</td></tr><tr><td><code>du -ah --max-depth==1</code></td><td>查看当前目录下的文件及文件夹的大小</td><td></td></tr><tr><td><code>du -sh</code></td><td>查看当前文件夹大小</td><td></td></tr><tr><td><code>ls -ltr</code></td><td>按修改时间排序</td><td></td></tr><tr><td><code>ls -l</code>&#124;<code>wc -l</code></td><td>查看当前文件夹下文件及文件夹个数</td><td></td></tr><tr><td><code>ls -l</code>&#124;<code>grep &quot;^-&quot;</code>&#124;<code>wc -l</code></td><td>查看当前文件夹下文件个数</td><td></td></tr><tr><td><code>ls -l</code>&#124;<code>grep &quot;^d&quot;</code>&#124;<code>wc -l</code></td><td>查看当前文件夹下文件夹个数</td><td></td></tr><tr><td><code>free</code></td><td>查看内存使用情况</td><td>内存</td></tr><tr><td><code>top</code></td><td>实时显示系统运行各项信息，相当于任务管理器</td><td>cpu</td></tr><tr><td><code>ps -ef</code>&#124;<code>grep sth</code></td><td>查看当前运行进程</td><td></td></tr><tr><td><code>rename &#39;s/\.cc$/.cpp/&#39; *.cc</code></td><td>将后缀为.cc的文件后缀修改为.cpp</td><td>批量修改文件名</td></tr><tr><td><code>rename &#39;s/\s/./&#39; *.c</code></td><td>将后缀为.c的文件名中的空格替换为”.”</td><td>批量修改文件名</td></tr><tr><td><code>rename &#39;s/^/00/&#39; [0-9]*</code></td><td>将文件名以数字开头的文件前面加上00</td><td>批量修改文件名</td></tr><tr><td><code>history</code>&#124;<code>awk &#39;{print $2}&#39;</code>&#124;<code>sort</code>&#124;<code>uniq -c</code>&#124;<code>sort -rn</code>&#124;<code>head -15</code></td><td>查看使用频次前15的历史命令</td><td></td></tr><tr><td><code>linuxlogo</code></td><td></td><td></td></tr><tr><td><code>wc [filename]</code></td><td>统计指定文件中的行数、字数、字节数</td><td></td></tr><tr><td><code>usermod -l [新用户名] -d /home/[新用户名] -m [旧用户名]</code></td><td>修改用户名</td><td></td></tr><tr><td><code>ln</code></td><td>链接，软链接，硬链接</td><td></td></tr><tr><td><code>scp</code></td><td>linux之间文件远程传输</td><td></td></tr><tr><td><code>more</code></td><td>与cat类似，可以翻页浏览,空格键下一页，b回上一页</td><td></td></tr><tr><td><code>less</code></td><td>与more类似，还可以使用vi编辑查找</td><td></td></tr><tr><td><code>awk</code></td><td>AWK是一种处理文本文件的语言，是一个强大的文本分析工具</td><td></td></tr><tr><td><code>:%s/foo/bar/g</code></td><td>全文查找替换</td><td></td></tr><tr><td><code>gg=G</code></td><td>vim中代码智能对齐</td><td>vim</td></tr><tr><td><code>nl [file]</code></td><td>查看文件内容，行号计算不包括空行，相当于<code>cat [file] -b</code></td><td></td></tr><tr><td><code>:%!xxd</code></td><td>vim中显示16进制</td><td>vim</td></tr><tr><td><code>:%!xxd -r</code></td><td>vim中从16进制恢复</td><td>vim</td></tr><tr><td><code>sed -i &#39;1,6d&#39; *.cpp</code></td><td>删除所有cpp文件的前六行</td><td></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux常用命令&quot;&gt;&lt;a href=&quot;#Linux常用命令&quot; class=&quot;headerlink&quot; title=&quot;Linux常用命令&quot;&gt;&lt;/a&gt;Linux常用命令&lt;/h1&gt;
    
    </summary>
    
    
      <category term="shell" scheme="https://wmjtxt.github.io/tags/shell/"/>
    
      <category term="c" scheme="https://wmjtxt.github.io/tags/c/"/>
    
      <category term="linux" scheme="https://wmjtxt.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Epoll、Select与poll</title>
    <link href="https://wmjtxt.github.io/2019/03/09/epoll/"/>
    <id>https://wmjtxt.github.io/2019/03/09/epoll/</id>
    <published>2019-03-09T04:00:00.000Z</published>
    <updated>2019-06-27T07:34:05.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-epoll"><a href="#1-epoll" class="headerlink" title="1.epoll"></a>1.epoll</h1><p>epoll是linux特有的I/O复用函数。它在实现和使用上与select、poll有很大差异。</p><ul><li>首先，epoll使用一组函数来完成任务，而不是单个函数。</li><li>其次，epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中，从而无须像select和poll那样每次调用都要重复传入文件描述符集或事件集。</li><li>但epoll需要使用一个额外的文件描述符，来唯一标示内核中的这个事件表。<a id="more"></a></li><li>这个文件描述符使用<code>epoll_create</code>函数来创建：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p>size参数现在不起作用,只是给内核一个提示，告诉它事件表需要多大。</p><ul><li><code>epoll_ctl</code>用来操作epoll的内核事件表。</li><li><p>epoll系列系统调用的主要接口是<code>epoll_wait</code>函数。</p></li><li><p>epoll对文件描述符的操作有两种模式：LT和ET</p><ul><li>LT（Level Trigger，电平触发）模式是默认的工作模式，在这种模式下epoll相当于一个效率较高的poll。</li><li>ET（Edge Trigger，边沿触发）模式是epoll的高效工作模式。</li></ul></li></ul><h1 id="2-poll"><a href="#2-poll" class="headerlink" title="2.poll"></a>2.poll</h1><p>poll系统调用和select类似，也是在指定时间内轮询一定数量的文件描述符，以测试其中是否有就绪者。poll的原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd* fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></p><ul><li>fds参数是一个pollfd结构类型的数组，它指定所有我们感兴趣的文件描述符上发生的可读、可写和异常等事件。pollfd结构体的定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;         <span class="comment">//文件描述符</span></span><br><span class="line">    <span class="keyword">short</span> events;   <span class="comment">//注册的事件</span></span><br><span class="line">    <span class="keyword">short</span> revents;  <span class="comment">//实际发生的事件，由内核填充</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="3-select"><a href="#3-select" class="headerlink" title="3.select"></a>3.select</h1><p>select的用途：在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br></pre></td></tr></table></figure></p><p>其中：</p><ul><li>nfds参数指定被监听的文件描述符的总数。</li><li>readfds,writefds,exceptfds参数分别指向可读、可写和异常等事件对应的文件描述符。</li><li>timeout参数用来设置select函数的超时时间。如果timeout传递NULL，则select将一直阻塞，直到某个文件描述符就绪。</li></ul><table><thead><tr><th style="text-align:center">系统调用</th><th style="text-align:center">select</th><th style="text-align:center">poll</th><th style="text-align:center">epoll</th></tr></thead><tbody><tr><td style="text-align:center">事件集合</td><td style="text-align:center">用户通过3个参数<br>分别传入感兴趣的<br>可读、可写及异常<br>等事件，内核通过<br>对这些参数的在线<br>修改来反馈其中的<br>就绪事件。这使得<br>用户每次调用select<br>都要重置这<br>3个参数</td><td style="text-align:center">统一处理所有事件<br>类型，因此只需<br>一个事件集参数。用<br>户通过pollfd.events<br>传入感兴趣的事件，<br>内核通过修改<br>pollfd.revents反馈<br>其中就绪的事件</td><td style="text-align:center">内核通过一个事件表<br>直接管理用户感兴趣的<br>所有事件。因此每次<br>调用epoll_wait时，<br>无须反复传入用户感<br>兴趣的事件。epoll_wait<br>系统调用的参数events<br>仅用来反馈就绪的事件</td></tr><tr><td style="text-align:center">应用程序索引<br>就绪文件描述符<br>的时间复杂度</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">最大支持<br>文件描述符数</td><td style="text-align:center">一般有最大值限制，1024或2048</td><td style="text-align:center">65535</td><td style="text-align:center">65535</td></tr><tr><td style="text-align:center">工作模式</td><td style="text-align:center">LT</td><td style="text-align:center">LT</td><td style="text-align:center">LT,同时支持ET高效模式</td></tr><tr><td style="text-align:center">内核实现<br>和工作效率</td><td style="text-align:center">采用轮询方式来<br>检测就绪事件，<br>算法时间复杂度为<br>O(n)</td><td style="text-align:center">采用轮询方式<br>来检测就绪事件，<br>算法时间复杂度为<br>O(n)</td><td style="text-align:center">采用回调方式来<br>检测就绪事件，<br>算法时间复杂度为<br>O(1)</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-epoll&quot;&gt;&lt;a href=&quot;#1-epoll&quot; class=&quot;headerlink&quot; title=&quot;1.epoll&quot;&gt;&lt;/a&gt;1.epoll&lt;/h1&gt;&lt;p&gt;epoll是linux特有的I/O复用函数。它在实现和使用上与select、poll有很大差异。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，epoll使用一组函数来完成任务，而不是单个函数。&lt;/li&gt;
&lt;li&gt;其次，epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中，从而无须像select和poll那样每次调用都要重复传入文件描述符集或事件集。&lt;/li&gt;
&lt;li&gt;但epoll需要使用一个额外的文件描述符，来唯一标示内核中的这个事件表。
    
    </summary>
    
    
      <category term="Linux" scheme="https://wmjtxt.github.io/tags/Linux/"/>
    
      <category term="技术" scheme="https://wmjtxt.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Socket" scheme="https://wmjtxt.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>LeedCode 37.Sudoku Solver</title>
    <link href="https://wmjtxt.github.io/2019/03/07/LeedCode_37_Sudoku_Solver/"/>
    <id>https://wmjtxt.github.io/2019/03/07/LeedCode_37_Sudoku_Solver/</id>
    <published>2019-03-07T04:00:00.000Z</published>
    <updated>2019-06-27T07:34:05.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeedCode-37-Sudoku-Solver"><a href="#LeedCode-37-Sudoku-Solver" class="headerlink" title="LeedCode 37.Sudoku Solver"></a>LeedCode 37.Sudoku Solver</h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><a id="more"></a><p>就是数独游戏</p><h1 id="解法思路"><a href="#解法思路" class="headerlink" title="解法思路"></a>解法思路</h1><p>把所有空位置找出来,并找到该位置可以填的数字的集合.针对每个空位置,把其集合中的数字依次填进去验证(这里采用递归):</p><pre><code>* 如果返回flase,就把该位置重新设为空,验证集合中的下一个数字* 直到递归完成,返回true</code></pre><h1 id="解法分析"><a href="#解法分析" class="headerlink" title="解法分析"></a>解法分析</h1><ul><li>方法1: 采用set\&lt;char>存储数字集合,Runtime: 248ms(unordered_set也差不多)</li><li>方法2: 采用vector\&lt;int>表示数字集合,Runtime: 36ms</li><li>方法3: 采用int,位运算表示数字集合,Runtime: 12ms</li><li>可见,能用简单数据结构实现还是最好的</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><ul><li><p>方法1:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        solve(board);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; tmp;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; ++k)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(board[i][k] != <span class="string">'.'</span>)</span><br><span class="line">                            tmp.insert(board[i][k]);</span><br><span class="line">                        <span class="keyword">if</span>(board[k][j] != <span class="string">'.'</span>)</span><br><span class="line">                            tmp.insert(board[k][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">3</span>; ++m)&#123;</span><br><span class="line">                            <span class="keyword">int</span> ii = i/<span class="number">3</span>*<span class="number">3</span>+k;</span><br><span class="line">                            <span class="keyword">int</span> jj = j/<span class="number">3</span>*<span class="number">3</span>+m;</span><br><span class="line">                            <span class="keyword">if</span>(board[ii][jj] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                                tmp.insert(board[ii][jj]);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'1'</span>; c &lt;= <span class="string">'9'</span>; ++c)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(tmp.find(c) == tmp.end())&#123;</span><br><span class="line">                            board[i][j] = c;</span><br><span class="line">                            <span class="keyword">if</span>(solve(board))</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>方法2:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        solve(board);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(<span class="number">9</span>,<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; ++k)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(board[i][k] != <span class="string">'.'</span>)</span><br><span class="line">                            tmp[board[i][k]-<span class="string">'0'</span><span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(board[k][j] != <span class="string">'.'</span>)</span><br><span class="line">                            tmp[board[k][j]-<span class="string">'0'</span><span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(board[i/<span class="number">3</span>*<span class="number">3</span>+k/<span class="number">3</span>][j/<span class="number">3</span>*<span class="number">3</span>+k%<span class="number">3</span>] != <span class="string">'.'</span>)</span><br><span class="line">                            tmp[board[i/<span class="number">3</span>*<span class="number">3</span>+k/<span class="number">3</span>][j/<span class="number">3</span>*<span class="number">3</span>+k%<span class="number">3</span>]-<span class="string">'0'</span><span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; ++k)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!tmp[k])&#123;</span><br><span class="line">                            board[i][j] = k + <span class="string">'0'</span> + <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">if</span>(solve(board))</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>方法3:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        solve(board);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> row = <span class="number">0x1ff</span>;</span><br><span class="line">                    <span class="keyword">int</span> col = <span class="number">0x1ff</span>;</span><br><span class="line">                    <span class="keyword">int</span> squ = <span class="number">0x1ff</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; ++k)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(board[i][k] != <span class="string">'.'</span>)</span><br><span class="line">                            row ^= <span class="number">1</span> &lt;&lt; (board[i][k] - <span class="number">49</span>);</span><br><span class="line">                        <span class="keyword">if</span>(board[k][j] != <span class="string">'.'</span>)</span><br><span class="line">                            col ^= <span class="number">1</span> &lt;&lt; (board[k][j] - <span class="number">49</span>);</span><br><span class="line">                        <span class="keyword">if</span>(board[i/<span class="number">3</span>*<span class="number">3</span>+k/<span class="number">3</span>][j/<span class="number">3</span>*<span class="number">3</span>+k%<span class="number">3</span>] != <span class="string">'.'</span>)</span><br><span class="line">                            squ ^= <span class="number">1</span> &lt;&lt; (board[i/<span class="number">3</span>*<span class="number">3</span> + k/<span class="number">3</span>][j/<span class="number">3</span>*<span class="number">3</span> + k%<span class="number">3</span>] - <span class="number">49</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> flag = row &amp; col &amp; squ;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; ++k,flag&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(flag%<span class="number">2</span>)&#123;</span><br><span class="line">                            board[i][j] = k + <span class="string">'0'</span> + <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">if</span>(solve(board))</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LeedCode-37-Sudoku-Solver&quot;&gt;&lt;a href=&quot;#LeedCode-37-Sudoku-Solver&quot; class=&quot;headerlink&quot; title=&quot;LeedCode 37.Sudoku Solver&quot;&gt;&lt;/a&gt;LeedCode 37.Sudoku Solver&lt;/h1&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://wmjtxt.github.io/tags/LeetCode/"/>
    
      <category term="刷题" scheme="https://wmjtxt.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 438.Find All Anagrams in a String</title>
    <link href="https://wmjtxt.github.io/2019/03/06/LeedCode_438/"/>
    <id>https://wmjtxt.github.io/2019/03/06/LeedCode_438/</id>
    <published>2019-03-06T04:00:00.000Z</published>
    <updated>2019-06-27T07:34:05.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="438-Find-All-Anagrams-in-a-String"><a href="#438-Find-All-Anagrams-in-a-String" class="headerlink" title="438.Find All Anagrams in a String"></a>438.Find All Anagrams in a String</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h2><a id="more"></a><p>Given a string s and a non-empty string p, find all the start indices of p’s anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter.</p><p>给定一个字符串s和一个非空字符串p，在s中查找p的变位词的所有起始索引。字符串仅由小写英文字母组成，字符串s和p的长度将不大于20,100。输出顺序无关紧要。 </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一开始，我只当是字符串匹配来做了，做出来发现最后一个超时，又加了KMP，还是超时。后来也有了想法，只是花太多时间了，就没有再去写，于是参考大神的解法。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法1(没有AC，并且考虑不周全)：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findAnagrams(<span class="built_in">string</span> s, <span class="built_in">string</span> p) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> m = p.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; dict;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e : p)</span><br><span class="line">            dict.insert(e);</span><br><span class="line">        sort(p.begin(), p.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n-m; ++i)&#123;</span><br><span class="line">            <span class="built_in">string</span> tmp = s.substr(i,m);</span><br><span class="line">            <span class="comment">//cout &lt;&lt; tmp &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dict.find(tmp[j]) == dict.end())&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sort(tmp.begin(), tmp.end());</span><br><span class="line">            <span class="keyword">if</span>(j == m)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p == tmp)&#123;</span><br><span class="line">                    res.push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i += j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法2(滑动窗口)：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findAnagrams(<span class="built_in">string</span> s, <span class="built_in">string</span> p) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pv(<span class="number">26</span>,<span class="number">0</span>), sv(<span class="number">26</span>,<span class="number">0</span>), res;</span><br><span class="line">        <span class="keyword">if</span>(s.size() &lt; p.size())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ++pv[p[i]-<span class="string">'a'</span>];</span><br><span class="line">            ++sv[s[i]-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pv == sv)</span><br><span class="line">           res.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = p.size(); i &lt; s.size(); ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            ++sv[s[i]-<span class="string">'a'</span>];</span><br><span class="line">            --sv[s[i-p.size()]-<span class="string">'a'</span>]; </span><br><span class="line">            <span class="keyword">if</span>(pv == sv)</span><br><span class="line">                res.push_back(i-p.size()+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;438-Find-All-Anagrams-in-a-String&quot;&gt;&lt;a href=&quot;#438-Find-All-Anagrams-in-a-String&quot; class=&quot;headerlink&quot; title=&quot;438.Find All Anagrams in a String&quot;&gt;&lt;/a&gt;438.Find All Anagrams in a String&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述:&quot;&gt;&lt;/a&gt;题目描述:&lt;/h2&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://wmjtxt.github.io/tags/LeetCode/"/>
    
      <category term="刷题" scheme="https://wmjtxt.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契数列三种解法及时间复杂度分析</title>
    <link href="https://wmjtxt.github.io/2018/12/26/three_method_of_fibonacci/"/>
    <id>https://wmjtxt.github.io/2018/12/26/three_method_of_fibonacci/</id>
    <published>2018-12-25T16:00:00.000Z</published>
    <updated>2019-06-27T07:34:05.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-定义及递推公式"><a href="#1-定义及递推公式" class="headerlink" title="1.定义及递推公式"></a>1.定义及递推公式</h1><p>斐波那契数列(Fibonacci sequence),又称黄金分割数列，因数学家Leonardoda Fibonacci以兔子繁殖为例子而引入，故又称兔子数列。<br>1,1,2,3,5,8,13…<br>即：f(1) = 1,f(2) = 1,f(3) = 2,f(4) = 3…<br>添加0项后,Fibonacci数列归纳如下：<br><a id="more"></a></p><ul><li>f(n) = f(n-1) + f(n-2), n &gt;= 2;</li><li>f(0) = 0;</li><li>f(1) = 1;</li></ul><h1 id="2-通项公式"><a href="#2-通项公式" class="headerlink" title="2.通项公式"></a>2.通项公式</h1><p><img src="/images/fibonacci.jpg" alt="txgs"></p><h1 id="3-方法一：递归求解-时间复杂度O-2-n"><a href="#3-方法一：递归求解-时间复杂度O-2-n" class="headerlink" title="3.方法一：递归求解(时间复杂度O(2^n))"></a>3.方法一：递归求解(时间复杂度O(2^n))</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">unsigned</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/fb4.png" alt="txgs"> <img src="/images/fbn.png" alt="txgs"></p><p>时间复杂度分析：可以看到,递归解法存在大量的重复计算。<br>求f(n)的过程可以用一颗二叉树表示,树中的每个节点就代表一次基本计算.<br>易知,树的高度为n,一棵高度为n的满二叉树的节点个数为2^n-1,当然,上图中的树肯定不是满二叉树,但也可以看出来,该树的节点个数<br>大于满二叉树节点数的一半,即（2^n-1)/2,设计算次数为T(n),可知(2^n-1)/2 &lt; T(n) &lt; 2^n-1.<br>因此该算法的时间复杂度为O(2^n).</p><h1 id="4-方法二：利用动态规划-dp-求解-时间复杂度O-n"><a href="#4-方法二：利用动态规划-dp-求解-时间复杂度O-n" class="headerlink" title="4.方法二：利用动态规划(dp)求解(时间复杂度O(n))"></a>4.方法二：利用动态规划(dp)求解(时间复杂度O(n))</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fibonacci_dp</span><span class="params">(<span class="keyword">unsigned</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">long</span> dp[n+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然,动态规划解法的时间复杂度为O(n).</p><h1 id="5-方法三：利用矩阵求解-时间复杂度O-logn"><a href="#5-方法三：利用矩阵求解-时间复杂度O-logn" class="headerlink" title="5.方法三：利用矩阵求解(时间复杂度O(logn)"></a>5.方法三：利用矩阵求解(时间复杂度O(logn)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">unsigned</span> n;</span><br><span class="line">    <span class="keyword">long</span> **m;</span><br><span class="line">    Matrix(<span class="keyword">unsigned</span> num)</span><br><span class="line">    &#123;</span><br><span class="line">        m=<span class="keyword">new</span> <span class="keyword">long</span>*[num];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>; i&lt;num; i++) &#123;</span><br><span class="line">            m[i]=<span class="keyword">new</span> <span class="keyword">long</span>[num];</span><br><span class="line">        &#125;</span><br><span class="line">        n=num;</span><br><span class="line">        clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> j=<span class="number">0</span>; j&lt;n; ++j) &#123;</span><br><span class="line">                m[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">            m[i][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>=(<span class="keyword">const</span> Matrix mtx)</span><br><span class="line">    &#123;</span><br><span class="line">        Matrix(mtx.n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>; i&lt;mtx.n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> j=<span class="number">0</span>; j&lt;mtx.n; ++j) &#123;</span><br><span class="line">                m[i][j]=mtx.m[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix &amp;mtx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">result</span><span class="params">(mtx.n)</span></span>;</span><br><span class="line">        result.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>; i&lt;mtx.n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> j=<span class="number">0</span>; j&lt;mtx.n; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">unsigned</span> k=<span class="number">0</span>; k&lt;mtx.n; ++k) &#123;</span><br><span class="line">                    result.m[i][j]+=m[i][k]*mtx.m[k][j];</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fb_matrix</span><span class="params">(<span class="keyword">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> num=<span class="number">2</span>;</span><br><span class="line">    <span class="function">Matrix <span class="title">first</span><span class="params">(num)</span></span>;</span><br><span class="line">    first.m[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    first.m[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    first.m[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    first.m[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="function">Matrix <span class="title">result</span><span class="params">(num)</span></span>;</span><br><span class="line">    result.unit();</span><br><span class="line">    <span class="keyword">unsigned</span> t=n<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">while</span> (t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t%<span class="number">2</span>) &#123;</span><br><span class="line">            result=result*first;</span><br><span class="line">            &#125;</span><br><span class="line">        first=first*first;</span><br><span class="line">        t=t/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.m[<span class="number">0</span>][<span class="number">0</span>]+result.m[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据递推公式可以得到<br><img src="/images/fibonacci_matrix.png" alt="matrix"><br>因而计算f(n)就简化为计算矩阵的(n-2)次方，而计算矩阵的(n-2)次方，又可以分解为计算矩阵的(n-2)/2次方的平方,逐步分解,直到(n-2)/(2^m)==1,因而时间复杂度为O(logn).<br>matrix解法的时间复杂度为O(logn).</p><h1 id="6-运行结果比较"><a href="#6-运行结果比较" class="headerlink" title="6.运行结果比较"></a>6.运行结果比较</h1><p><img src="/images/fibonacci_result40.png" alt="40"><br><img src="/images/fibonacci_result90.png" alt="90"></p><ul><li>可以看到，后两种解法比递归解法明显要快很多。</li><li>当n = 40时,动态规划解法比矩阵解法还要快些,都比递归解法快得多。</li><li>当n取更大些，比如n = 90时,动态规划解法就比矩阵解法慢了。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-定义及递推公式&quot;&gt;&lt;a href=&quot;#1-定义及递推公式&quot; class=&quot;headerlink&quot; title=&quot;1.定义及递推公式&quot;&gt;&lt;/a&gt;1.定义及递推公式&lt;/h1&gt;&lt;p&gt;斐波那契数列(Fibonacci sequence),又称黄金分割数列，因数学家Leonardoda Fibonacci以兔子繁殖为例子而引入，故又称兔子数列。&lt;br&gt;1,1,2,3,5,8,13…&lt;br&gt;即：f(1) = 1,f(2) = 1,f(3) = 2,f(4) = 3…&lt;br&gt;添加0项后,Fibonacci数列归纳如下：&lt;br&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://wmjtxt.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="C++" scheme="https://wmjtxt.github.io/tags/C/"/>
    
      <category term="斐波那契" scheme="https://wmjtxt.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"/>
    
  </entry>
  
  <entry>
    <title>LPA算法C++实现及模块度计算</title>
    <link href="https://wmjtxt.github.io/2018/11/12/lpa%E7%AE%97%E6%B3%95c++%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%A8%A1%E5%9D%97%E5%BA%A6%E8%AE%A1%E7%AE%97/"/>
    <id>https://wmjtxt.github.io/2018/11/12/lpa算法c++实现及模块度计算/</id>
    <published>2018-11-11T16:00:00.000Z</published>
    <updated>2019-06-27T07:34:05.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这学期开始看社团检测的东西，了解了一些经典算法。比如GN算法，BGLL算法(又叫Louvain，<br>因为该算法是作者在Louvain大学时提出的)，LPA算法，等等。</p><a id="more"></a><p>我先看的LPA（毕竟算法思想最简单,hhh，怪我太笨了），又看了Louvain。<br>Louvain算法的代码，作者在文章里给了网址，是C++写的，我下到本地运行并认真研究了一下，写的真挺好的。<br>然后昨天突发奇想，干脆自己仿照Louvain的代码风格，用C++把LPA实现一下，<br>因为在网上只看到过Python和Java实现的LPA算法，还没见过C++实现的。</p><p>然后昨天把框架写好，今天把细节补全，最后又从Louvain的代码里搬来了模块度的计算部分。<br>最后调试好，就OK啦。</p><h1 id="1-LPA基本思想"><a href="#1-LPA基本思想" class="headerlink" title="1.LPA基本思想"></a>1.LPA基本思想</h1><p>给每一个节点添加标签，初始时可以以各自的nodeid作为标签，标签传播过程中将一个节点的邻居节点的标签中<br>数量最多的标签作为该节点的标签。标签即代表所属社区。</p><ul><li>1 初始时，给每个节点一个标签，通常以其id作为初始标签。</li><li>2 每个节点使用其邻居节点的标签中数量最多的标签更新自身标签。</li><li>3 反复执行步骤2，直到满足终止条件。(至于终止条件是什么，这个可以自己设置,<br>  比如我就直接设定迭代5次结束，也可以根据每次迭代模块度的增加程度来设定，<br>  网上有说直到每个节点的标签不再变化为止，其实这比较难判定，<br>  而且据研究，大部分网络经过5次迭代，其95%的节点标签都不再变化，<br>  后面每次迭代虽部分标签还在变化，但相比来说性价比不高了)</li></ul><p>LPA算法的优点是收敛周期很短，而且不需要任何先验知识。时间复杂度接近线性：对节点分配标签为O(n)，<br>每次迭代需要遍历所有的边两次，也就是O(2m)，所以时间复杂度为O(n+2m)，其中n为节点数，m为边数。</p><p>同步更新和异步更新还没搞懂，回头看看再说。</p><p><strong>缺点</strong> </p><ul><li>1 由于迭代过程中可能会出现随机选择的情况，所以LPA算法具有不稳定性，也就是同一个网络每次执行的结果可能都不一样。</li><li>2 可能出现巨型社区。</li></ul><p><strong>算法改进思路</strong></p><ul><li>目前还没</li></ul><h1 id="2-数据集"><a href="#2-数据集" class="headerlink" title="2.数据集"></a>2.数据集</h1><p><strong><em>dolphins</em></strong></p><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lpa.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_time</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line"><span class="keyword">time_t</span> rawtime;</span><br><span class="line">time ( &amp;rawtime );</span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; str &lt;&lt; <span class="string">" : "</span> &lt;&lt; ctime (&amp;rawtime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//parse_args(argc, argv);</span></span><br><span class="line"><span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; <span class="string">"argc not 2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> filename = argv[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"filename = "</span> &lt;&lt; filename &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">time_t</span> time_begin, time_end;</span><br><span class="line">time(&amp;time_begin);</span><br><span class="line">display_time(<span class="string">"start"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//sleep(3);</span></span><br><span class="line"><span class="function">LPA <span class="title">lpa</span><span class="params">(filename)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"初始模块度 = "</span> &lt;&lt; lpa.modularity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">lpa.labeled();</span><br><span class="line">lpa.display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">display_time(<span class="string">"end"</span>);</span><br><span class="line"></span><br><span class="line">time(&amp;time_end);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-运行结果"><a href="#4-运行结果" class="headerlink" title="4.运行结果"></a>4.运行结果</h1><p><img src="/images/lpa1.png" alt="运行结果1"><br><img src="/images/lpa2.png" alt="运行结果2"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这学期开始看社团检测的东西，了解了一些经典算法。比如GN算法，BGLL算法(又叫Louvain，&lt;br&gt;因为该算法是作者在Louvain大学时提出的)，LPA算法，等等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="复杂网络" scheme="https://wmjtxt.github.io/tags/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C/"/>
    
      <category term="LPA" scheme="https://wmjtxt.github.io/tags/LPA/"/>
    
  </entry>
  
  <entry>
    <title>去掉Deepin登录界面的模糊效果</title>
    <link href="https://wmjtxt.github.io/2018/11/06/deepin-lockscreen/"/>
    <id>https://wmjtxt.github.io/2018/11/06/deepin-lockscreen/</id>
    <published>2018-11-05T16:00:00.000Z</published>
    <updated>2019-06-27T07:34:05.888Z</updated>
    
    <content type="html"><![CDATA[<p>引自: <a href="https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=149463&amp;extra=" target="_blank" rel="noopener">https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=149463&amp;extra=</a></p><p>其实这个页面我收藏了，但今天想设置的时候网络不好页面打不开，所以自己复制一个吧。</p><p>deepin会将所有切换过的锁屏壁纸模糊效果保存到目录：/var/cache/image-blur/下<br><a id="more"></a></p><ul><li>1.首先把这个文件夹下的所有文件都删除;</li><li>2.锁屏;</li><li>3.再次登录后，进到这个文件夹下，就可以看到只有一个文件(file.jpg);</li><li>4.把需要用的图片替换掉这个文件即可。<ul><li><code>sudo cp 需要使用的图片.jpg /var/cache/image-blur/file.jpg</code></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引自: &lt;a href=&quot;https://bbs.deepin.org/forum.php?mod=viewthread&amp;amp;tid=149463&amp;amp;extra=&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://bbs.deepin.org/forum.php?mod=viewthread&amp;amp;tid=149463&amp;amp;extra=&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实这个页面我收藏了，但今天想设置的时候网络不好页面打不开，所以自己复制一个吧。&lt;/p&gt;
&lt;p&gt;deepin会将所有切换过的锁屏壁纸模糊效果保存到目录：/var/cache/image-blur/下&lt;br&gt;
    
    </summary>
    
    
      <category term="Deepin" scheme="https://wmjtxt.github.io/tags/Deepin/"/>
    
  </entry>
  
  <entry>
    <title>一些想法</title>
    <link href="https://wmjtxt.github.io/2018/10/28/somethinkings/"/>
    <id>https://wmjtxt.github.io/2018/10/28/somethinkings/</id>
    <published>2018-10-27T16:00:00.000Z</published>
    <updated>2019-06-27T07:34:05.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工作现状"><a href="#工作现状" class="headerlink" title="工作现状"></a>工作现状</h2><ul><li>项目, 进展很慢</li><li>技术, 提高有限</li><li>论文, 看不进去<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br><span class="line"><span class="number">1.</span>项目，我主要负责数据预处理，使用Java，真是不太会，写的很慢，一个小想法都要搞一天。</span><br><span class="line">  比如之前，数据库存储过程我就搞了一天才运行成功。最后发现只是个小错误卡住了，细心还是很重要的。</span><br><span class="line"><span class="number">2.</span>技术主要是通过看书刷题来提高，目前是在LeetCode和PAT上刷，语言主要是C++，每天各<span class="number">1</span><span class="number">-2</span>道，刷的还是很慢的，无奈技术太差。</span><br><span class="line"><span class="number">3.</span>论文，可以说还没有开始。想法是先看社团检测的经典算法并实现，至少弄懂各个算法，</span><br><span class="line">  然后再看有没有可以写成论文的想法，其实我要求不高，水一篇EI就行了。</span><br></pre></td></tr></table></figure></li></ul><p>Deepin上印象笔记不太好用，这样记笔记有些麻烦啊。<br>以后可以每天早上或头天晚上，开始做事之前，先写个<code>todolist.md</code>，这样目标清晰，可能做的更快一点。<br>如果有一个点卡住了，可以先做下一个，卡住的地方说不定会突然有思路，然后再回去接着做就行。</p><p>今天就这样，写个todolist去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;工作现状&quot;&gt;&lt;a href=&quot;#工作现状&quot; class=&quot;headerlink&quot; title=&quot;工作现状&quot;&gt;&lt;/a&gt;工作现状&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;项目, 进展很慢&lt;/li&gt;
&lt;li&gt;技术, 提高有限&lt;/li&gt;
&lt;li&gt;论文, 看不进去&lt;figure clas
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://wmjtxt.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>从Excel导数据到MySQL</title>
    <link href="https://wmjtxt.github.io/2018/10/17/importDatatoMySQL/"/>
    <id>https://wmjtxt.github.io/2018/10/17/importDatatoMySQL/</id>
    <published>2018-10-16T16:00:00.000Z</published>
    <updated>2019-06-27T07:34:05.888Z</updated>
    
    <content type="html"><![CDATA[<p><strong>运行环境:</strong> Windows10 和 Deepin15.7, MySQL14.4, Java1.8.0_181<br><br><strong>使用工具:</strong> poi,JDBC<br><br><strong>数据规模:</strong> 35万条，5个文件夹，146个Excel文件(.xls,.xlsx)</p><a id="more"></a><p>一开始在win10里运行，需要3个小时，把我吓到了，当时也没多想，导完数据就做处理去了。<br>后来到deepin里导(电脑装的双系统)，同样的数据，同样的代码，只需要100秒左右，又把我吓到了，这差距咋这么大呢。虽然deepin装在固态里，但也不至于直接差了整整一百倍吧。</p><p>然后我就又回到win10，想着做一下优化，看能不能快点，因为在网上看到有说把日志关了会快一些。我试了下，时间一下子提高到160多秒!好吧，原来就是日志的问题。</p><p>然后我又把deepin里MySQL的日志开启，测试了一下，974454ms，约16分钟，还是比win10快不少的。</p><p><strong>MySQL在win10里默认日志开启，而deepin里默认日志关闭。</strong></p><p><strong>win10的MySQL日志关闭方法:</strong></p><ul><li>找到my.ini文件，在里面加入一行:skip-log-bin，保存关闭，重启MySQL服务。</li></ul><p><strong>deepin的MySQL日志开启方法:</strong></p><ul><li>`sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</li><li><code>找到里面的</code>server-id<code>和</code>log_bin`这两行，把前面的#删掉</li><li>回到上一层路径，执行<code>./debian-start</code>(这一步是必须的，一开始我没执行，仅修改上面的两行后，mysql服务开启不了)</li><li><code>sevice mysql restart</code> 重启MySQL服务</li></ul><p>当然，除了关闭日志，我还做了其他的优化，比如String改为StringBuffer,Statement改为PreparedStatement等，不过这些都提高不明显。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;运行环境:&lt;/strong&gt; Windows10 和 Deepin15.7, MySQL14.4, Java1.8.0_181&lt;br&gt;&lt;br&gt;&lt;strong&gt;使用工具:&lt;/strong&gt; poi,JDBC&lt;br&gt;&lt;br&gt;&lt;strong&gt;数据规模:&lt;/strong&gt; 35万条，5个文件夹，146个Excel文件(.xls,.xlsx)&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://wmjtxt.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="mysql" scheme="https://wmjtxt.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>配置Deepin</title>
    <link href="https://wmjtxt.github.io/2018/09/29/myDeepin/"/>
    <id>https://wmjtxt.github.io/2018/09/29/myDeepin/</id>
    <published>2018-09-28T16:00:00.000Z</published>
    <updated>2019-06-27T07:34:05.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#chrome">Chrome</a></li><li><a href="#ssh">SSH</a></li><li><a href="#git">Git</a></li><li><a href="#gcc">GCC</a></li><li><a href="#youcompleteme">YouCompleteMe</a></li><li><a href="#mysql">MySQL</a></li><li><a href="#vim-instant-markdown">vim-instant-markdown</a></li><li><a href="#variety">Variety</a></li><li><a href="#conky">Conky</a></li><li><a href="#pycharm">Pycharm</a></li><li><a href="#texstudio">TexStudio</a></li><li><a href="#atom">Atom</a></li><li><a href></a></li></ul><a id="more"></a><h1 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h1><p>Deepin现在好像是自带Chrome。不过还需要登录Google账户同步书签，这才是最重要的。而登录Google账户必须翻-墙。<br>现如今梯子越来越难找了，很多都被封了。<br>目前能用的是这个<a href="https://github.com/yinghuocho/firefly-proxy" target="_blank" rel="noopener">firefly</a>，下载安装，然后打开会弹出一个页面，随便注册一个账户就有两天的时长可以用。</p><p>真心希望有一天能取消这厚厚的wall。<br>当然也真心希望有一天我们的技术能领先全球。</p><h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><ul><li>安装ssh<ul><li><code>sudo apt-get install openssh-server</code></li></ul></li><li>开启ssh服务<ul><li><code>sudo service sshd start</code></li></ul></li></ul><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><ul><li>安装git<ul><li><code>sudo apt-get install git</code></li></ul></li><li>设置name和email<ul><li><code>git config --global user.name &quot;name&quot;</code></li><li><code>git config --global user.email &quot;email&quot;</code></li></ul></li><li>设置ssh-key<ul><li>先执行<code>ssh-keygen -t rsa -C &quot;email&quot;</code></li><li>然后在github上找到”Account settings”,”SSH Keys”页面,点击”Add SSH Key”,将~/.ssh/id_rsa.pub的内容粘贴到Key文本框内。</li></ul></li><li>连接远程库<ul><li><code>git remote add origin git@github.com:yourname/reponame.git</code></li></ul></li><li>常用命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git push origin master</span><br><span class="line">git pull origin master</span><br><span class="line">git add -A</span><br><span class="line">git commit -m &quot;text&quot;</span><br><span class="line">git status</span><br><span class="line">git log</span><br><span class="line">git clone repoAddress</span><br></pre></td></tr></table></figure></li></ul><h1 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h1><ul><li><p>系统好像是自带了gcc,但g++需要手动安装</p></li><li><p><code>sudo apt-get install g++</code></p></li></ul><h1 id="YouCompleteMe"><a href="#YouCompleteMe" class="headerlink" title="YouCompleteMe"></a>YouCompleteMe</h1><p>一款强大的vim插件</p><p>安装方法参考：<a href="https://wmjtxt.github.io/2018/05/14/%E5%9C%A8deepin%E4%B8%8A%E5%AE%89%E8%A3%85YouCompleteMe/">安装YouCompleteMe</a></p><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h1 id="vim-instant-markdown"><a href="#vim-instant-markdown" class="headerlink" title="vim-instant-markdown"></a>vim-instant-markdown</h1><p>一款vim插件，可以实现markdown文件即时预览</p><p>安装方法参考：<a href="https://github.com/yangyangwithgnu/use_vim_as_ide#8.4" target="_blank" rel="noopener">https://github.com/yangyangwithgnu/use_vim_as_ide.git</a></p><h1 id="Variety"><a href="#Variety" class="headerlink" title="Variety"></a>Variety</h1><p>Variety是一款自动更换壁纸的软件<br>直接在深度商店安装或者<code>sudo apt-get install variety</code></p><h1 id="Conky"><a href="#Conky" class="headerlink" title="Conky"></a>Conky</h1><p>Conky是一款可以显示天气的桌面软件。来源：深度论坛</p><ul><li><a href="https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=148009&amp;highlight=conky" target="_blank" rel="noopener">deepin利用conky打造一个炫酷的桌面</a></li><li><a href="https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=152734&amp;highlight=conky" target="_blank" rel="noopener">conky-weather 3.0 (Conky天气)</a></li></ul><p>我用的第二个</p><h1 id="Pycharm"><a href="#Pycharm" class="headerlink" title="Pycharm"></a>Pycharm</h1><p><code>sudo apt-get install pycharm-community</code></p><h1 id="TexStudio"><a href="#TexStudio" class="headerlink" title="TexStudio"></a>TexStudio</h1><p>Latex编辑器</p><ul><li>首先安装texlive, 可以直接在官网下载下来安装, <a href="http://mirror.ctan.org/systems/texlive/tlnet/install-tl-unx.tar.gz" target="_blank" rel="noopener">install-tl-unx.tar.gz</a>, 也可以命令安装, <code>sudo apt-get install texlive-full</code></li><li>然后安装texstudio, <code>sudo apt-get install texstudio</code></li></ul><h1 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h1><p>开源文本编辑器, <code>sudo apt-get install atom</code>, 也可以在深度商店安装</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#chrome&quot;&gt;Chrome&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#ssh&quot;&gt;SSH&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#git&quot;&gt;Git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#gcc&quot;&gt;GCC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#youcompleteme&quot;&gt;YouCompleteMe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#mysql&quot;&gt;MySQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#vim-instant-markdown&quot;&gt;vim-instant-markdown&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#variety&quot;&gt;Variety&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#conky&quot;&gt;Conky&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#pycharm&quot;&gt;Pycharm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#texstudio&quot;&gt;TexStudio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#atom&quot;&gt;Atom&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Deepin" scheme="https://wmjtxt.github.io/tags/Deepin/"/>
    
  </entry>
  
  <entry>
    <title>社团检测基本概念</title>
    <link href="https://wmjtxt.github.io/2018/09/28/Community-Detection-values/"/>
    <id>https://wmjtxt.github.io/2018/09/28/Community-Detection-values/</id>
    <published>2018-09-27T16:00:00.000Z</published>
    <updated>2019-06-27T07:34:05.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-模块度-Modularity"><a href="#1-模块度-Modularity" class="headerlink" title="1.模块度(Modularity)"></a>1.模块度(Modularity)</h2><p>&emsp;&emsp;把划分社团后的网络与相应的零模型(Null model)进行比较，以度量社团划分划分的质量。一个网络的模块度定义为：该网络的社团内部边数与相应的零模型的社团内部变数之差占整个网络边数的比例。<br><br>&emsp;&emsp;计算公式为：<br><br><a id="more"></a></p><p><center><images src="http://chart.googleapis.com/chart?cht=tx&chl= Q = \sum\limits_{v}[e_{vv} - (a_v)^2]"></images></center><br></p><p>&emsp;&emsp;其中,<images src="http://chart.googleapis.com/chart?cht=tx&chl= e_{vv}">为社团v和社团w之间的连边占整个网络边数的比例。<images src="http://chart.googleapis.com/chart?cht=tx&chl= a_v">为一端与社团v中节点相连的边的比例。<br></images></images></p><h2 id="2-度中心性-Degree-centrality"><a href="#2-度中心性-Degree-centrality" class="headerlink" title="2.度中心性(Degree centrality)"></a>2.度中心性(Degree centrality)</h2><p>&emsp;&emsp;度中心性值定义为：<center><images src="http://chart.googleapis.com/chart?cht=tx&chl= DC_i = \frac{k_i}{N-1}"></images></center><br><br>&emsp;&emsp;其中，<images src="http://chart.googleapis.com/chart?cht=tx&chl= k_i">为节点i的度，N为网络中的节点个数。<br></images></p><h2 id="3-介数中心性-Betweenness-centrality"><a href="#3-介数中心性-Betweenness-centrality" class="headerlink" title="3.介数中心性(Betweenness centrality)"></a>3.介数中心性(Betweenness centrality)</h2><p>&emsp;&emsp;介数中心性是以经过某个节点的最短路径的数目来刻画节点重要性的指标,简称介数(BC)。<br><br>&emsp;&emsp;节点i的介数定义为：<center><images src="http://chart.googleapis.com/chart?cht=tx&chl= BC_i= \sum\limits_{s{\ne}i{\ne}t}\frac{n_{st}^{i}}{g_{st}}"></images></center><br><br>&emsp;&emsp;其中,<images src="http://chart.googleapis.com/chart?cht=tx&chl= g_{st}">为从节点s到节点t的最短路径的数目, <images src="http://chart.googleapis.com/chart?cht=tx&chl=n_{st}^{i}">为从节点s到节点t的<images src="http://chart.googleapis.com/chart?cht=tx&chl= g_{st}">条最短路径中经过节点i的最短路径的数目。</images></images></images></p><h2 id="4-接近中心性-Closeness-centrality"><a href="#4-接近中心性-Closeness-centrality" class="headerlink" title="4.接近中心性(Closeness centrality)"></a>4.接近中心性(Closeness centrality)</h2><p>接近数，即平均路径长度的倒数。</p><h2 id="5-k-壳与k-核"><a href="#5-k-壳与k-核" class="headerlink" title="5.k-壳与k-核"></a>5.k-壳与k-核</h2><h2 id="6-特征向量中心性"><a href="#6-特征向量中心性" class="headerlink" title="6.特征向量中心性"></a>6.特征向量中心性</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-模块度-Modularity&quot;&gt;&lt;a href=&quot;#1-模块度-Modularity&quot; class=&quot;headerlink&quot; title=&quot;1.模块度(Modularity)&quot;&gt;&lt;/a&gt;1.模块度(Modularity)&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;把划分社团后的网络与相应的零模型(Null model)进行比较，以度量社团划分划分的质量。一个网络的模块度定义为：该网络的社团内部边数与相应的零模型的社团内部变数之差占整个网络边数的比例。&lt;br&gt;&lt;br&gt;&amp;emsp;&amp;emsp;计算公式为：&lt;br&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="复杂网络" scheme="https://wmjtxt.github.io/tags/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
